"""Fixed Signal Generator with Debug Logging"""
import pandas as pd
import numpy as np
from typing import Dict, Any, Optional
from datetime import datetime
import logging
import json

from config import config
from trading.data_manager import DataManager
from trading.strategies import StrategyEngine
from trading.risk_manager import EnhancedRiskManager  # FIXED: Use Enhanced
from analysis.technical_indicators import TechnicalAnalysis

logger = logging.getLogger(__name__)

class DebugSignalGenerator:
    def __init__(self):
        self.data_manager = DataManager()
        self.strategy_engine = StrategyEngine()
        self.risk_manager = EnhancedRiskManager()  # FIXED: Enhanced version
        self.tech_analysis = TechnicalAnalysis()
        self.load_weights()
        logger.info("ğŸ”§ Debug Signal Generator initialized with Enhanced Risk Manager")
        
    def load_weights(self):
        try:
            with open(config.WEIGHTS_FILE, 'r') as f:
                self.weights = json.load(f)
            logger.info(f"ğŸ“Š Weights loaded: {self.weights}")
        except:
            self.weights = config.STRATEGY_WEIGHTS
            logger.info(f"ğŸ“Š Using default weights: {self.weights}")
            
    async def generate_signal(self) -> Optional[Dict[str, Any]]:
        try:
            logger.info("ğŸš€ Starting DEBUG signal generation...")
            
            best_signal = None
            best_score = 0
            
            for timeframe in config.TIMEFRAMES:
                logger.info(f"ğŸ“Š Analyzing timeframe: {timeframe}")
                
                # Get data with debug
                df = self.data_manager.get_data(timeframe, 500)
                if df is None or df.empty:
                    logger.warning(f"âŒ No data for timeframe {timeframe}")
                    continue
                
                logger.info(f"âœ… Got {len(df)} bars for {timeframe}min")
                logger.info(f"ğŸ’° Current price: ${df['close'].iloc[-1]:.2f}")
                
                # Add indicators with debug
                df = self.tech_analysis.add_indicators(df)
                logger.info(f"ğŸ“ˆ Technical indicators added")
                
                # Analyze strategies with detailed debug
                strategy_results = self.strategy_engine.analyze(df)
                logger.info(f"ğŸ§  Strategy analysis complete")
                
                # DEBUG: Log each strategy result
                for strategy_name, result in strategy_results.items():
                    direction = result.get('direction', 'NEUTRAL')
                    score = result.get('score', 0)
                    reason = result.get('reason', 'No reason')
                    weight = self.weights.get(strategy_name, 0)
                    weighted_score = score * weight
                    
                    logger.info(f"   ğŸ“Š {strategy_name}: {direction} | Score: {score} | Weight: {weight:.2f} | Weighted: {weighted_score:.1f}")
                    if direction != 'NEUTRAL':
                        logger.info(f"      Reason: {reason}")
                
                # Evaluate signals with debug
                signal = self.evaluate_signals_debug(strategy_results, df, timeframe)
                
                if signal and signal['score'] > best_score:
                    best_signal = signal
                    best_score = signal['score']
                    logger.info(f"ğŸ¯ New best signal: {signal['direction']} with score {best_score:.1f}")
            
            if best_signal and best_score >= config.MIN_SIGNAL_SCORE:
                logger.info(f"âœ… Signal passes threshold! Score: {best_score:.1f} >= {config.MIN_SIGNAL_SCORE}")
                
                # FIXED: Use correct method name
                best_signal = self.risk_manager.calculate_enhanced_risk_parameters(best_signal)
                best_signal['timestamp'] = datetime.now().isoformat()
                
                logger.info(f"ğŸ¯ FINAL SIGNAL: {best_signal['direction']} @ ${best_signal['entry']:.2f}")
                return best_signal
            
            elif best_signal:
                logger.info(f"âŒ Signal score too low: {best_score:.1f} < {config.MIN_SIGNAL_SCORE}")
                logger.info(f"ğŸ’¡ Try lowering MIN_SIGNAL_SCORE temporarily to test")
            else:
                logger.info("âŒ No signals generated by any strategy")
                
            return None
            
        except Exception as e:
            logger.error(f"âŒ Signal generation failed: {e}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")
            return None
    
    def evaluate_signals_debug(self, results: Dict, df: pd.DataFrame, timeframe: str) -> Optional[Dict]:
        logger.info(f"ğŸ” Evaluating signals for {timeframe}min...")
        
        buy_score = 0
        sell_score = 0
        buy_reasons = []
        sell_reasons = []
        
        logger.info(f"ğŸ“Š Processing {len(results)} strategy results...")
        
        for strategy, result in results.items():
            weight = self.weights.get(strategy, 0.1)
            direction = result.get('direction', 'NEUTRAL')
            score = result.get('score', 0)
            reason = result.get('reason', 'No reason')
            
            if direction == 'BUY':
                weighted_score = score * weight
                buy_score += weighted_score
                buy_reasons.append(f"{strategy}: {reason}")
                logger.info(f"   ğŸŸ¢ BUY: {strategy} adds {weighted_score:.1f} (score: {score}, weight: {weight:.2f})")
                
            elif direction == 'SELL':
                weighted_score = score * weight
                sell_score += weighted_score
                sell_reasons.append(f"{strategy}: {reason}")
                logger.info(f"   ğŸ”´ SELL: {strategy} adds {weighted_score:.1f} (score: {score}, weight: {weight:.2f})")
                
            else:
                logger.info(f"   âšª NEUTRAL: {strategy} (no contribution)")
        
        logger.info(f"ğŸ“Š TOTAL SCORES: BUY={buy_score:.1f}, SELL={sell_score:.1f}")
        
        current_price = df['close'].iloc[-1]
        
        if buy_score > sell_score and buy_score >= config.MIN_SIGNAL_SCORE:
            logger.info(f"ğŸŸ¢ BUY signal qualifies! Score: {buy_score:.1f}")
            return {
                'direction': 'BUY',
                'entry': current_price,
                'score': buy_score,
                'timeframe': f"M{timeframe}",
                'reasons': buy_reasons[:3],
                'strategies_triggered': len([r for r in results.values() if r['direction'] == 'BUY']),
                'symbol': config.PRIMARY_SYMBOL
            }
            
        elif sell_score > buy_score and sell_score >= config.MIN_SIGNAL_SCORE:
            logger.info(f"ğŸ”´ SELL signal qualifies! Score: {sell_score:.1f}")
            return {
                'direction': 'SELL',
                'entry': current_price,
                'score': sell_score,
                'timeframe': f"M{timeframe}",
                'reasons': sell_reasons[:3],
                'strategies_triggered': len([r for r in results.values() if r['direction'] == 'SELL']),
                'symbol': config.PRIMARY_SYMBOL
            }
        
        else:
            if buy_score > sell_score:
                logger.info(f"ğŸŸ¡ BUY signal too weak: {buy_score:.1f} < {config.MIN_SIGNAL_SCORE}")
                logger.info(f"   Top BUY reasons: {buy_reasons[:2]}")
            elif sell_score > buy_score:
                logger.info(f"ğŸŸ¡ SELL signal too weak: {sell_score:.1f} < {config.MIN_SIGNAL_SCORE}")
                logger.info(f"   Top SELL reasons: {sell_reasons[:2]}")
            else:
                logger.info(f"ğŸŸ¡ No clear direction: BUY={buy_score:.1f}, SELL={sell_score:.1f}")
        
        return None

# Replace the original SignalGenerator
SignalGenerator = DebugSignalGenerator